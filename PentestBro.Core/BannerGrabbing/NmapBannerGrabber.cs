using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using PentestBro.Model;
using PentestBro.Model.BannerGrabbing;

namespace PentestBro.Core.BannerGrabbing
{
    public class NmapBannerGrabber : IBannerGrabber
    {
        private NmapServiceProbeParser serviceProbeParser = new NmapServiceProbeParser();

        public string Grab(IPAddress ipAddress, ushort port, Layer4ProtocolType protocolType)
        {
            var sslServiceProbes = this.serviceProbeParser.GetSslServiceProbes(port, protocolType);
            var serviceProbes = this.serviceProbeParser.GetServiceProbes(port, protocolType);
            var results = new List<string>();

            foreach (var sslServiceProbe in sslServiceProbes)
            {
                var result = this.GrabSslBanner(sslServiceProbe, ipAddress, port);
                result = result.Replace("\0", "");

                if (result != string.Empty && result != "\r\n" && result != "\n" && result != "(" && results.Contains(result) == false)
                    results.Add(result);
            }

            foreach (var serviceProbe in serviceProbes)
            {
                var result = this.GrabBanner(serviceProbe, ipAddress, port);
                result = result.Replace("\0", "");

                if (result != string.Empty && result != "\u0015\u0003\u0002\u0002(" && result != "\u0015\u0003\u0001\u0002\u0002\n" && results.Contains(result) == false)
                    results.Add(result);
            }

            var returnValue = string.Join("\r\n\r\n###############\r\n\r\n", results);
            return returnValue;
        }

        private string GrabSslBanner(ServiceProbe serviceProbe, IPAddress ipAddress, ushort port)
        {
            var sendString = Regex.Unescape(serviceProbe.Probe);
            var bytes = Encoding.ASCII.GetBytes(sendString);

            try
            {
                if (serviceProbe.ProtocolType == Layer4ProtocolType.TCP)
                {
                    using (var client = new TcpClient())
                    {
                        client.ReceiveTimeout = 5000;

                        var endPoint = new IPEndPoint(ipAddress, port);
                        client.Connect(endPoint);

                        var networkStream = new SslStream(client.GetStream(), false, (w, x, y, z) => true);
                        networkStream.AuthenticateAsClient(ipAddress.ToString());

                        if (bytes.Length > 0)
                            networkStream.Write(bytes, 0, bytes.Length);

                        var receivedBytes = new byte[client.ReceiveBufferSize];
                        var bytesRead = 0;

                        try
                        {
                            bytesRead = networkStream.Read(receivedBytes, 0, client.ReceiveBufferSize);
                        }
                        catch (Exception)
                        {
                        }

                        var certificateDescription = this.ExtractCertificateInfo(networkStream);

                        var results = new List<string>();
                        results.Add(Encoding.ASCII.GetString(receivedBytes));
                        results.Add(certificateDescription);

                        var result = string.Join("\r\n\r\n###############\r\n\r\n", results);

                        return result;
                    }
                }
                else if (serviceProbe.ProtocolType == Layer4ProtocolType.UDP)
                {
                    using (var client = new UdpClient())
                    {
                        client.Client.SendTimeout = 5000;
                        client.Client.ReceiveTimeout = 5000;

                        var endPoint = new IPEndPoint(ipAddress, port);

                        client.Connect(endPoint);
                        client.Send(bytes, bytes.Length);

                        var receivedBytes = client.Receive(ref endPoint);
                        var result = Encoding.ASCII.GetString(receivedBytes);
                        return result;
                    }
                }
            }
            catch (Exception)
            {
                return string.Empty;
            }

            throw new NotImplementedException($"Unknown protocol '{serviceProbe.ProtocolType}'");
        }

        private string GrabBanner(ServiceProbe serviceProbe, IPAddress ipAddress, ushort port)
        {
            var sendString = Regex.Unescape(serviceProbe.Probe);
            var bytes = Encoding.ASCII.GetBytes(sendString);

            try
            {
                if (serviceProbe.ProtocolType == Layer4ProtocolType.TCP)
                {
                    using (var client = new TcpClient())
                    {
                        client.ReceiveTimeout = 5000;

                        var endPoint = new IPEndPoint(ipAddress, port);
                        client.Connect(endPoint);

                        var networkStream = client.GetStream();

                        if (bytes.Length > 0)
                            networkStream.Write(bytes, 0, bytes.Length);

                        var receivedBytes = new byte[client.ReceiveBufferSize];
                        var bytesRead = networkStream.Read(receivedBytes, 0, client.ReceiveBufferSize);
                        var result = Encoding.ASCII.GetString(receivedBytes);
                        return result;
                    }
                }
                else if (serviceProbe.ProtocolType == Layer4ProtocolType.UDP)
                {
                    using (var client = new UdpClient())
                    {
                        client.Client.SendTimeout = 5000;
                        client.Client.ReceiveTimeout = 5000;

                        var endPoint = new IPEndPoint(ipAddress, port);

                        client.Connect(endPoint);
                        client.Send(bytes, bytes.Length);

                        var receivedBytes = client.Receive(ref endPoint);
                        var result = Encoding.ASCII.GetString(receivedBytes);
                        return result;
                    }
                }
            }
            catch (Exception)
            {
                return string.Empty;
            }

            throw new NotImplementedException($"Unknown protocol '{serviceProbe.ProtocolType}'");
        }

        private string ExtractCertificateInfo(SslStream networkStream)
        {
            var certificate = networkStream.RemoteCertificate;
            var certificateDescription = "Certificate info:\r\n\r\n";
            certificateDescription += $"Issuer: {certificate?.Issuer}\r\n";
            certificateDescription += $"Subject: {certificate?.Subject}\r\n";
            certificateDescription += $"Valid: {certificate?.GetEffectiveDateString()} - {certificate?.GetExpirationDateString()}\r\n";
            certificateDescription += $"Protocol version: {networkStream.SslProtocol}\r\n";
            certificateDescription += $"Cipher algorithm: {networkStream.CipherAlgorithm} ({networkStream?.CipherStrength} bits)\r\n";

            var keyExchangeAlgorithm = networkStream.KeyExchangeAlgorithm.ToString();
            if (keyExchangeAlgorithm == "44550")
                keyExchangeAlgorithm = "ECDH Ephemeral";

            certificateDescription += $"Key exchange algorithm: {keyExchangeAlgorithm} ({networkStream?.KeyExchangeStrength} bits)\r\n";
            certificateDescription += $"Key algorithm: {this.GetKeyAlgorithmText(certificate?.GetKeyAlgorithm())} ({certificate?.GetKeyAlgorithm()})\r\n";
            certificateDescription += $"Key algorithm params: {certificate?.GetKeyAlgorithmParametersString()}\r\n";
            certificateDescription += $"Hash algorithm: {networkStream.HashAlgorithm} ({networkStream?.HashStrength} bits)\r\n";
            certificateDescription += $"Hash: {certificate?.GetCertHashString()}\r\n";
            certificateDescription += $"Serial No.: {certificate?.GetSerialNumberString()}\r\n";
            certificateDescription += $"Public Key: {certificate?.GetPublicKeyString()}";
            return certificateDescription;
        }

        private string GetKeyAlgorithmText(string keyAlgorithm)
        {
            switch (keyAlgorithm)
            {
                case "1.2.840.113549.1.1.1": return "RSA";
                case "1.2.840.10040.4.1": return "DSA";
                case "1.2.840.10046.2.1": return "DH";
                case "1.2.840.113549.1.1.10": return "RSASSA-PSS";
                case "1.3.14.3.2.12": return "DSA";
                case "1.2.840.113549.1.3.1": return "DH";
                case "1.3.14.3.2.22": return "RSA_KEYX";
                case "2.16.840.1.101.2.1.1.20": return "mosaicKMandUpdSig";
                case "1.2.840.113549.1.9.16.3.5": return "ESDH";
                case "1.3.6.1.5.5.7.6.2": return "NO_SIGN";
                case "1.2.840.10045.2.1": return "ECC";
                case "1.2.840.10045.3.1.7": return "ECDSA_P256";
                case "1.3.132.0.34": return "ECDSA_P384";
                case "1.3.132.0.35": return "ECDSA_P521";
                case "1.2.840.113549.1.1.7": return "RSAES_OAEP";
                case "1.3.133.16.840.63.0.2": return "ECDH_STD_SHA1_KDF";
                default: return keyAlgorithm;
            }
        }
    }
}
