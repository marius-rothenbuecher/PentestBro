using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using PacketDotNet;
using PacketDotNet.Utils;
using PcapDotNet.Packets;
using PcapDotNet.Packets.Ethernet;
using PcapDotNet.Packets.IpV4;
using PcapDotNet.Packets.Transport;
using PentestBro.Core.BannerGrabbing;
using SharpPcap;

namespace PentestBro.Core
{
    // TODO: check for rarity
    public class PortScanner
    {
        private const ushort SourcePort = 51337;
        private const ushort MaxPort = 65535;
        private readonly NmapServiceProbeParser serviceProbeParser = new NmapServiceProbeParser();
        private readonly ConcurrentDictionary<ushort, bool> openPorts = new ConcurrentDictionary<ushort, bool>();
        private readonly EthernetLayer ethernetLayer;
        private readonly IpV4Layer ipv4Layer;
        private readonly TcpLayer tcpLayer;
        private readonly UdpLayer udpLayer;
        private readonly CaptureDevice captureDevice = CaptureDevice.Instance;

        public PortScanner()
        {
            var random = new Random(DateTime.Now.Millisecond);

            this.ethernetLayer = new EthernetLayer()
            {
                Source = new MacAddress(this.captureDevice.MacAddress),
                Destination = new MacAddress(this.captureDevice.DefaultGatewayMacAddress),
                EtherType = EthernetType.IpV4,
            };

            var identification = (ushort)random.Next(ushort.MinValue, ushort.MaxValue);

            this.ipv4Layer = new IpV4Layer()
            {
                Source = new IpV4Address(this.captureDevice.IpAddress.ToString()),
                Identification = identification,
                Ttl = 128,
            };

            var sequenceNumber = (ushort)random.Next(int.MinValue, int.MaxValue);

            this.tcpLayer = new TcpLayer()
            {
                SequenceNumber = sequenceNumber,
                SourcePort = SourcePort,
                ControlBits = TcpControlBits.Synchronize,
                Options = new TcpOptions(new TcpOptionMaximumSegmentSize(1460)),
                Window = 1024,
            };

            this.udpLayer = new UdpLayer()
            {
                SourcePort = SourcePort,
            };
        }

        public IList<ushort> UdpScan(string ipAddress)
        {
            this.openPorts.Clear();

            var serviceProbes = this.serviceProbeParser.GetUdpServiceProbes();

            this.captureDevice.OnPacketArrival += this.ReceivedNewPacket;
            this.captureDevice.StartCapture($"udp dst port " + SourcePort);

            var packets = new List<PcapDotNet.Packets.Packet>();

            foreach (var serviceProbe in serviceProbes)
            {
                foreach (var port in serviceProbe.Ports)
                {
                    this.ipv4Layer.CurrentDestination = new IpV4Address(ipAddress.ToString());
                    this.ipv4Layer.Protocol = IpV4Protocol.Udp;
                    this.udpLayer.DestinationPort = (ushort)port;

                    var data = Regex.Unescape(serviceProbe.Probe);

                    var payloadLayer = new PayloadLayer
                    {
                        Data = new Datagram(Encoding.ASCII.GetBytes(data)),
                    };

                    var packetBuilder = new PacketBuilder(this.ethernetLayer, this.ipv4Layer, this.udpLayer,
                        payloadLayer);
                    packets.Add(packetBuilder.Build(DateTime.Now));
                }
            }

            foreach (var packet in packets)
                this.captureDevice.SendPacket(packet.Buffer);

            Thread.Sleep(10000);

            this.captureDevice.StopCapture();
            this.captureDevice.OnPacketArrival -= this.ReceivedNewPacket;

            return this.openPorts.Keys.OrderBy(x => x).ToList();
        }

        public IList<ushort> SynScan(string ipAddress)
        {
            var numberOfPortsPerBurst = 5000;
            var numberOfBursts = Math.Ceiling((double)MaxPort / numberOfPortsPerBurst);

            this.openPorts.Clear();
            this.captureDevice.OnPacketArrival += this.ReceivedNewPacket;
            this.captureDevice.StartCapture("tcp dst port " + SourcePort);

            for (var burstNumber = 0; burstNumber < numberOfBursts; burstNumber++)
            {
                var packets = new List<PcapDotNet.Packets.Packet>();
                var startPort = burstNumber * numberOfPortsPerBurst + 1;
                var endPort = Math.Min(startPort + numberOfPortsPerBurst, 65535 + 1);

                for (; startPort < endPort; startPort++)
                {
                    this.ipv4Layer.CurrentDestination = new IpV4Address(ipAddress.ToString());
                    this.ipv4Layer.Protocol = IpV4Protocol.Tcp;
                    this.tcpLayer.DestinationPort = (ushort)startPort;

                    var packetBuilder = new PacketBuilder(this.ethernetLayer, this.ipv4Layer, this.tcpLayer);
                    packets.Add(packetBuilder.Build(DateTime.Now));
                }

                foreach (var packet in packets)
                    this.captureDevice.SendPacket(packet.Buffer);

                Thread.Sleep(1000);
            }

            Thread.Sleep(3000);

            this.captureDevice.StopCapture();
            this.captureDevice.OnPacketArrival -= this.ReceivedNewPacket;

            return this.openPorts.Keys.OrderBy(x => x).ToList();
        }

        private void ReceivedNewPacket(object sender, CaptureEventArgs e)
        {
            var retrievedPacket = e.Packet;

            if (retrievedPacket?.Data == null)
                return;

            var ethernetPacket = new EthernetPacket(new ByteArraySegment(retrievedPacket.Data));
            var ipPacket = (IPPacket)ethernetPacket.PayloadPacket;

            if (ipPacket.PayloadPacket is TcpPacket tcpPacket)
            {
                if (tcpPacket.Syn && tcpPacket.Ack)
                {
                    this.openPorts.AddOrUpdate(tcpPacket.SourcePort, true, (x, y) => true);

                    // this.SendRstPacket(ethernetPacket, ipPacket, tcpPacket);
                }
            }
            else if (ipPacket.PayloadPacket is UdpPacket udpPacket)
            {
                this.openPorts.AddOrUpdate(udpPacket.SourcePort, true, (x, y) => true);
            }
        }

        private void SendRstPacket(EthernetPacket ethernetPacket, IPPacket ipPacket, TcpPacket tcpPacket)
        {
            var sourceHwAddress = PhysicalAddress.Parse(ethernetPacket.SourceHwAddress.ToString());
            var sourceAddress = IPAddress.Parse(ipPacket.SourceAddress.ToString());
            var acknowledgementNumber = tcpPacket.AcknowledgmentNumber;
            var sourcePort = tcpPacket.SourcePort;

            ethernetPacket.SourceHwAddress = ethernetPacket.DestinationHwAddress;
            ethernetPacket.DestinationHwAddress = sourceHwAddress;

            ipPacket.SourceAddress = ipPacket.DestinationAddress;
            ipPacket.DestinationAddress = sourceAddress;

            tcpPacket.Syn = false;
            tcpPacket.Ack = false;
            tcpPacket.Rst = true;
            tcpPacket.AcknowledgmentNumber = tcpPacket.SequenceNumber;
            tcpPacket.SequenceNumber = acknowledgementNumber;
            tcpPacket.SourcePort = tcpPacket.DestinationPort;
            tcpPacket.DestinationPort = sourcePort;
            tcpPacket.Checksum = tcpPacket.CalculateTCPChecksum();

            ethernetPacket.UpdateCalculatedValues();
            ipPacket.UpdateCalculatedValues();
            tcpPacket.UpdateCalculatedValues();

            ipPacket.PayloadPacket = tcpPacket;
            ethernetPacket.PayloadPacket = ipPacket;

            this.captureDevice.SendPacket(ethernetPacket);
        }
    }
}
