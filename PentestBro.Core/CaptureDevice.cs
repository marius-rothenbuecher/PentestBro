using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows;
using PacketDotNet;
using PacketDotNet.Utils;
using PcapDotNet.Packets;
using PcapDotNet.Packets.Arp;
using PcapDotNet.Packets.Ethernet;
using SharpPcap;
using SharpPcap.LibPcap;

namespace PentestBro.Core
{
    public class CaptureDevice
    {
        [DllImport("iphlpapi.dll")]
        public static extern int SendARP(int destinationIp, int sourceIp, [Out] byte[] macAddress, ref int macLength);

        private readonly ConcurrentDictionary<IPAddress, bool> onlineIpAddresses = new ConcurrentDictionary<IPAddress, bool>();
        private readonly Semaphore semaphore = new Semaphore(1, 1);
        private readonly LibPcapLiveDevice device;

        static CaptureDevice()
        {
        }

        private CaptureDevice()
        {
            var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
            var networkInterface = networkInterfaces
                .Where(x => x.OperationalStatus == OperationalStatus.Up)
                .Where(x => x.GetIPProperties() != null)
                .First(x => x.GetIPProperties().GatewayAddresses.Any(y => y.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork));

            this.IpAddress = networkInterface.GetIPProperties().UnicastAddresses.Where(x => x.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork).Select(x => x.Address).First();
            var gatewayAddress = networkInterface.GetIPProperties().GatewayAddresses.First();

            try
            {
                this.device = LibPcapLiveDeviceList.Instance.First(x => x.Interface.Name.Contains(networkInterface.Id));
            }
            catch (Exception)
            {
                MessageBox.Show($"{nameof(PentestBro)} will not work properly, please install WinPCAP correctly.");
                return;
            }

            this.device.Open(DeviceMode.Normal, 20);

            this.DefaultGatewayMacAddress = this.GetMacAddress(gatewayAddress.Address);

            for (var i = 0; i < 12; i++)
            {
                this.MacAddress += device.MacAddress.ToString()[i];

                if (i == 1 || i == 3 || i == 5 || i == 7 || i == 9)
                    this.MacAddress += ":";
            }
        }

        ~CaptureDevice()
        {
            this.device.Close();
        }

        public event PacketArrivalEventHandler OnPacketArrival
        {
            add { this.device.OnPacketArrival += value; }
            remove { this.device.OnPacketArrival -= value; }
        }

        public static CaptureDevice Instance { get; } = new CaptureDevice();
        public string MacAddress { get; }
        public string DefaultGatewayMacAddress { get; }
        public IPAddress IpAddress { get; }

        private string GetMacAddress(IPAddress ip)
        {
            var ipAddress = ip;
            var length = 6;
            var mac = new byte[length];

            SendARP((int)ipAddress.Address, 0, mac, ref length);

            var macAddress = BitConverter.ToString(mac, 0, length).Replace("-", ":");

            return macAddress;
        }

        public void StartCapture(string filter = "")
        {
            this.semaphore.WaitOne();
            this.device.Filter = filter;
            this.device.StartCapture();
        }

        public void StopCapture()
        {
            this.device.StopCapture();
            this.semaphore.Release();
        }

        public void SendPacket(byte[] buffer)
        {
            this.device.SendPacket(buffer);
        }

        public IList<IPAddress> GetLanIpAddresses()
        {
            var packets = new List<PcapDotNet.Packets.Packet>();
            var ipAddressesToScan = this.device.Addresses.Where(x => x.Addr.sa_family == 2).SelectMany(x => this.GetIpAddresses(x.Addr, x.Netmask)).ToList();

            this.OnPacketArrival += this.ReceivedNewPacket;
            this.StartCapture("arp");
            var arp = new ARP(this.device);

            var ethernetLayer = new EthernetLayer()
            {
                Source = new MacAddress(this.MacAddress),
                Destination = new MacAddress("FF:FF:FF:FF:FF:FF"),
                EtherType = EthernetType.Arp,
            };

            foreach (var ipAddressToScan in ipAddressesToScan)
            {
                var arpLayer = new ArpLayer()
                {
                    Operation = ArpOperation.Request,
                    ProtocolType = EthernetType.IpV4,
                    SenderHardwareAddress = new ReadOnlyCollection<byte>(PhysicalAddress.Parse(this.MacAddress.Replace(":", "-")).GetAddressBytes()),
                    SenderProtocolAddress = new ReadOnlyCollection<byte>(this.IpAddress.GetAddressBytes()),
                    TargetHardwareAddress = new ReadOnlyCollection<byte>(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }),
                    TargetProtocolAddress = new ReadOnlyCollection<byte>(ipAddressToScan.GetAddressBytes()),
                };

                var packetBuilder = new PacketBuilder(ethernetLayer, arpLayer);
                packets.Add(packetBuilder.Build(DateTime.Now));
            }

            foreach (var packet in packets)
            {
                this.SendPacket(packet.Buffer);
                Thread.Sleep(100);
            }

            Thread.Sleep(1000);

            this.StopCapture();
            this.OnPacketArrival -= this.ReceivedNewPacket;

            return this.onlineIpAddresses.Keys.ToList();
        }

        private void ReceivedNewPacket(object sender, CaptureEventArgs e)
        {
            var retrievedPacket = e.Packet;
            var ethernetPacket = new EthernetPacket(new ByteArraySegment(retrievedPacket.Data));
            var arpPacket = (ARPPacket)ethernetPacket.PayloadPacket;

            if (arpPacket.Operation == ARPOperation.Response)
            {
                this.onlineIpAddresses.AddOrUpdate(arpPacket.SenderProtocolAddress, true, (x, y) => true);
            }
        }

        public void SendPacket(PacketDotNet.Packet packet)
        {
            this.device.SendPacket(packet);
        }

        private IList<IPAddress> GetIpAddresses(Sockaddr ipSockaddr, Sockaddr maskSockaddr)
        {
            var ipAddresses = new List<IPAddress>();
            var ipAddressBytes = ipSockaddr.ipAddress.GetAddressBytes();
            var networkMaskBytes = maskSockaddr.ipAddress.GetAddressBytes();
            var subnetAddressBytes = new byte[ipAddressBytes.Length];
            var broadcastAddressBytes = new byte[ipAddressBytes.Length];

            for (int i = 0; i < ipAddressBytes.Length; i++)
                subnetAddressBytes[i] = (byte)(ipAddressBytes[i] & networkMaskBytes[i]);

            for (int i = 0; i < ipAddressBytes.Length; i++)
                broadcastAddressBytes[i] = (byte)(subnetAddressBytes[i] | (networkMaskBytes[i] ^ 0xFF));

            var subnetAddress = new IPAddress(subnetAddressBytes);
            var broadcastAddress = new IPAddress(broadcastAddressBytes);
            var currentIpAddress = new IPAddress(subnetAddressBytes);

            do
            {
                currentIpAddress = this.GetNextIpAddress(currentIpAddress, 1);
                ipAddresses.Add(currentIpAddress);
            } while (currentIpAddress.ToString() != broadcastAddress.ToString());

            return ipAddresses;
        }

        private IPAddress GetNextIpAddress(IPAddress ipAddress, uint increment)
        {
            var addressBytes = BitConverter.IsLittleEndian ? ipAddress.GetAddressBytes().Reverse().ToArray() : ipAddress.GetAddressBytes().ToArray();
            var ipAsUint = BitConverter.ToUInt32(addressBytes, 0);
            var nextAddress = BitConverter.GetBytes(ipAsUint + increment);
            return IPAddress.Parse(string.Join(".", nextAddress.Reverse()));
        }
    }
}
